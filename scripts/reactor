#!/usr/bin/env bash
#
# Usage:
#
#  reactor [flags] <command> [args] [flags/options]
#
#=========================================================================================
# Initialization
#
# Initialize top level directories and load bootstrap functions
SCRIPT_PATH="${BASH_SOURCE[0]}" # bash
if [[ -z "$SCRIPT_PATH" ]]; then
  SCRIPT_PATH="${(%):-%N}" # zsh
fi

((return 0 2>/dev/null) || [[ $ZSH_EVAL_CONTEXT =~ :file$ ]]) && SOURCED=1 || SOURCED=0

export __script_name="${__script_name:-$(basename "${SCRIPT_PATH//-/ }")}"
export __command_name="$1"
export __script_dir="$(cd "$(dirname "${SCRIPT_PATH}")" && pwd)"
source "${__script_dir}/reactor-env" $SOURCED

if [[ $SOURCED -eq 1 ]]; then
  # script is being sourced
  return
fi
delete_minikube_docker_environment

COMMAND_HOST_FUNCTION="${__command_name}_host_command"

export __app_args=("$@")
export __normalized_params="$(normalize_params "$@")"

parse_flag '-h|--help' arg_h
parse_flag --verbose arg_v
parse_flag --debug arg_d
parse_flag --no-color arg_n
#
#=========================================================================================
# Execution
#

# Error handling
set -o errexit
set -o errtrace
set -o nounset
set -o pipefail

# Log check
[[ "${LOG_LEVEL:-6}" ]] || emergency "Cannot continue without LOG_LEVEL"

# Debug mode
if [ "$arg_d" ]; then
  #set -o xtrace
  PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
  LOG_LEVEL="7"
  # Enable error backtracing
  trap '__err_report "${FUNCNAME:-.}" ${LINENO}' ERR
fi

# Verbose mode
if [ "$arg_v" ]; then
  set -o verbose
fi

# No color mode
if [ "$arg_n" ]; then
  NO_COLOR="true"
fi

# Display help
if [ ${#__app_args[@]} -eq 0 ]; then
  arg_h="1"
fi

if [[ "$__os" == "darwin" ]]; then
  REACTOR_DOCKER_SOCKET_FILE="${REACTOR_DOCKER_SOCKET_FILE:-/var/run/docker.sock.raw}"
  REACTOR_DOCKER_GROUP="0"
else
  REACTOR_DOCKER_SOCKET_FILE="${REACTOR_DOCKER_SOCKET_FILE:-/var/run/docker.sock}"
  REACTOR_DOCKER_GROUP="$(stat -L -c '%g' /var/run/docker.sock)"
fi
export REACTOR_DOCKER_SOCKET_FILE
export REACTOR_RUNTIME_IMAGE="${REACTOR_RUNTIME_IMAGE:-"${APP_NAME}:${__reactor_version}"}"

if [ -z ${REACTOR_DOCKER_RUN_ARGS+x} ]; then
  export REACTOR_DOCKER_RUN_ARGS=()
fi

REACTOR_ARGS=(
  "--rm"
  "--interactive"
  "--tty"
  "--network" "host"
  "--volume" "${REACTOR_DOCKER_SOCKET_FILE}:/var/run/docker.sock"
  "--volume" "${__reactor_dir}:/reactor"
  "--volume" "${__project_dir}:${__project_dir}"
  "--workdir" "${__project_dir}"
  "--env" "__script_name=${__script_name}"
)

ENVIRONMENT="$(current_environment)"
for variable in ${ENVIRONMENT[@]}; do
  REACTOR_ARGS=("${REACTOR_ARGS[@]}" "--env" "$variable")
done

for share_dir_name in ${HOME_SHARES[@]}; do
  if [ -e "${__home_dir}/${share_dir_name}" ]; then
    REACTOR_ARGS=("${REACTOR_ARGS[@]}" "--volume" "${__home_dir}/${share_dir_name}:${__home_dir}/${share_dir_name}")
  fi
done

if [[ -z "${__project_file}" ]] && [[ "${__command_name}" != "create" ]]; then
  echo ""
  error "Project directory with a 'reactor.yml' file does not exist in current or parent directories"
  echo ""
fi

if [[ -z "$APP_NAME" ]] \
  && ([[ "$arg_h" ]] || [[ "${__command_name}" == "help" ]]); then
  debug "Entering local help: --help flag or help command"
  reactor-exec "${__app_args[@]}"
else
  if [[ -z "${__project_file}" ]] \
    && [[ "${__command_name}" != "create" ]] \
    && [[ -z "$arg_h" ]]; then
    debug "Exiting due to no project, not creating, and no help specified"
    exit 1
  fi

  if [ "${__command_name}" != "create" ]; then
    if ! docker inspect "$REACTOR_RUNTIME_IMAGE" >/dev/null 2>&1; then
      debug "Building local virtualization container"
      "${__script_dir}/reactor-build"
      REACTOR_RUNTIME_IMAGE="${APP_NAME}:${__reactor_version}"
    fi
  fi
  REACTOR_ARGS=("${REACTOR_ARGS[@]}" "${REACTOR_DOCKER_RUN_ARGS[@]}" "$REACTOR_RUNTIME_IMAGE")

  debug "======================================"
  debug "Reactor Arguments: ${REACTOR_ARGS[@]}"
  debug "======================================"

  if [ ${#__app_args[@]} -gt 0 ]; then
    debug "__app_args: ${__app_args[@]}"

    if [ "${__app_args[0]}" == "enter" ]; then
      info "Entering reactor environment ..."

      docker run --entrypoint bash "${REACTOR_ARGS[@]}"
      exit
    elif [ "${__app_args[0]}" == "create" ]; then
      reactor-exec "${__app_args[@]}"
      exit
    fi
  fi

  # Containerized execution (primary command logic)
  debug "Running reactor command ..."
  docker run "${REACTOR_ARGS[@]}" "${__app_args[@]}"
fi

if [ $? -eq 0 ]; then
  # Local execution (use sparingly)
  if function_exists $COMMAND_HOST_FUNCTION; then
    COMMAND_ARGS=( "${__app_args[@]:1}" )

    reactor_args "${COMMAND_ARGS[@]}"
    parse_environment "${__command_name}"

    COMMAND_INIT_FUNCTION="${COMMAND_HOST_FUNCTION}_init"
    COMMAND_EXIT_FUNCTION="${COMMAND_HOST_FUNCTION}_exit"

    if function_exists $COMMAND_INIT_FUNCTION; then
      $COMMAND_INIT_FUNCTION "${COMMAND_ARGS[@]:-}"
    fi

    $COMMAND_HOST_FUNCTION "${COMMAND_ARGS[@]:-}"

    if function_exists $COMMAND_EXIT_FUNCTION; then
      $COMMAND_EXIT_FUNCTION "${COMMAND_ARGS[@]:-}"
    fi

    # Source finalization scripts
    exec_hook finalize_host
  fi
fi
