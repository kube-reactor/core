#!/usr/bin/env bash
#
# Usage:
#
#  reactor-exec [flags] <command> [args] [flags/options]
#
#=========================================================================================
# Initialization
#

# Initialize top level directories and load bootstrap functions
SCRIPT_PATH="${BASH_SOURCE[0]}" # bash
if [[ -z "$SCRIPT_PATH" ]]; then
  SCRIPT_PATH="${(%):-%N}" # zsh
fi

((return 0 2>/dev/null) || [[ $ZSH_EVAL_CONTEXT =~ :file$ ]]) && SOURCED=1 || SOURCED=0

export __script_dir="$(cd "$(dirname "${SCRIPT_PATH}")" && pwd)"
source "${__script_dir}/reactor-env"

if [[ $SOURCED -eq 1 ]]; then
  # script is being sourced
  return
fi

echo "" >"$(logfile)"
debug "====================================================================="
debug "Executing reactor command: $@"

debug "Environment variables"
debug "======================================"
debug "$(env)"


# Parameter parsing
function usage () {
  cat <<EOF >&2

  Reactor manages development Kubernetes environments

  Usage:

    kubectl reactor [flags] [command] [flags/options]

  Flags:
${__reactor_core_flags}

  Commands:

EOF
  for function_name in $(compgen -A function); do
    if [[ "$function_name" == *"_command" ]]; then
      command_name=${function_name%"_command"}
      command_description="${command_name}_description"

      if function_exists $command_description; then
        printf "    %-20s  %s\n" "$command_name" "$($command_description)" >&2
      fi
    fi
  done
  echo "" >&2
  echo "  Use 'kubectl reactor <command> --help' for more information about a given command" >&2
  echo "" >&2
  exit 1
}


COMMAND_ARGS=()
arg_processed=0

[[ $# -eq 0 ]] && arg_h=1

while [[ $# -gt 0 ]]; do
  case "$1" in
    --verbose)
      arg_v=1
      shift
      ;;
    --debug)
      arg_d=1
      shift
      ;;
    --no-color)
      arg_n=1
      shift
      ;;
    -h|--help)
      if [ $arg_processed -ne 1 ]; then
        arg_h=1
      else
        COMMAND_ARGS+=("$1")
      fi
      shift
      ;;
    *)
      COMMAND_ARGS+=("$1")
      arg_processed=1
      shift
      ;;
  esac
done

#
#=========================================================================================
# Execution
#

# Error handling
set -o errexit
set -o errtrace
set -o nounset
set -o pipefail

# Log check
[[ "${LOG_LEVEL:-6}" ]] || emergency "Cannot continue without LOG_LEVEL"

# Debug mode
if [[ "${arg_d:-0}" = "1" ]]; then
  #set -o xtrace
  PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
  LOG_LEVEL="7"
  # Enable error backtracing
  trap '__err_report "${FUNCNAME:-.}" ${LINENO}' ERR
fi

# Verbose mode
if [[ "${arg_v:-0}" = "1" ]]; then
  set -o verbose
fi

# No color mode
if [[ "${arg_n:-0}" = "1" ]]; then
  NO_COLOR="true"
fi


debug "Top level flags"
debug "> Debug: ${arg_d:-0}"
debug "> Verbosity: ${arg_v:-0}"
debug "> Help: ${arg_h:-0}"

debug "Script properties"
debug "> OS type: ${OSTYPE}"
debug "> OS name: ${__os}"
debug "> CPU arch: ${__architecture}"
debug "> Invocation: ${__reactor_invocation}"
debug "> Reactor directory: ${__reactor_dir}"
debug "> Script directory: ${__script_dir}"

debug "Project and development properties"
debug "> Project directory: ${__project_dir}"
debug "> Project manifest: ${__project_file}"
debug "> Certificate directory: ${__certs_dir}"
debug "> Executable directory: ${__binary_dir}"
debug "> Docker image project root directory: ${__docker_dir}"
debug "> Helm chart project root directory: ${__charts_dir}"
debug "> Terraform project root directory: ${__terraform_dir}"


if [[ "${arg_h:-0}" = "1" ]] || [[ ${#COMMAND_ARGS[@]} -eq 0 ]]; then
  usage
else
  COMMAND="${COMMAND_ARGS[0]}"
  COMMAND_ARGS=("${COMMAND_ARGS[@]:1}")
  COMMAND_FUNCTION="${COMMAND}_command"

  if [ "$COMMAND" == "help" ]; then
    if ! [[ ${#COMMAND_ARGS[@]} -gt 0 ]]; then
      usage
    else
      HELP_COMMAND="${COMMAND_ARGS[0]}_command"

      if function_exists $HELP_COMMAND; then
        $HELP_COMMAND --help
      else
        error "Unknown command: ${HELP_COMMAND}"
        usage
      fi
    fi
  elif function_exists $COMMAND_FUNCTION; then
    COMMAND_INIT_FUNCTION="${COMMAND_FUNCTION}_init"
    COMMAND_EXIT_FUNCTION="${COMMAND_FUNCTION}_exit"

    if function_exists $COMMAND_INIT_FUNCTION; then
      $COMMAND_INIT_FUNCTION "${COMMAND_ARGS[@]:-}"
    fi

    $COMMAND_FUNCTION "${COMMAND_ARGS[@]:-}"

    if function_exists $COMMAND_EXIT_FUNCTION; then
      $COMMAND_EXIT_FUNCTION "${COMMAND_ARGS[@]:-}"
    fi
  else
    error "Unknown command: ${COMMAND}"
    usage
  fi
fi

source "${__script_dir}/state/finalize.sh"
